// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: datasets.sql

package gensql

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const createBigqueryDatasource = `-- name: CreateBigqueryDatasource :one
INSERT INTO
  datasource_bigquery (
    "dataset_id",
    "project_id",
    "dataset",
    "table_name",
    "schema",
    "last_modified",
    "created",
    "expires",
    "table_type",
    "pii_tags",
    "pseudo_columns",
    "is_reference"
  )
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12
  ) RETURNING dataset_id, project_id, dataset, table_name, schema, last_modified, created, expires, table_type, description, pii_tags, missing_since, id, is_reference, pseudo_columns, deleted
`

type CreateBigqueryDatasourceParams struct {
	DatasetID     uuid.UUID
	ProjectID     string
	Dataset       string
	TableName     string
	Schema        pqtype.NullRawMessage
	LastModified  time.Time
	Created       time.Time
	Expires       sql.NullTime
	TableType     string
	PiiTags       pqtype.NullRawMessage
	PseudoColumns []string
	IsReference   bool
}

func (q *Queries) CreateBigqueryDatasource(ctx context.Context, arg CreateBigqueryDatasourceParams) (DatasourceBigquery, error) {
	row := q.db.QueryRowContext(ctx, createBigqueryDatasource,
		arg.DatasetID,
		arg.ProjectID,
		arg.Dataset,
		arg.TableName,
		arg.Schema,
		arg.LastModified,
		arg.Created,
		arg.Expires,
		arg.TableType,
		arg.PiiTags,
		pq.Array(arg.PseudoColumns),
		arg.IsReference,
	)
	var i DatasourceBigquery
	err := row.Scan(
		&i.DatasetID,
		&i.ProjectID,
		&i.Dataset,
		&i.TableName,
		&i.Schema,
		&i.LastModified,
		&i.Created,
		&i.Expires,
		&i.TableType,
		&i.Description,
		&i.PiiTags,
		&i.MissingSince,
		&i.ID,
		&i.IsReference,
		pq.Array(&i.PseudoColumns),
		&i.Deleted,
	)
	return i, err
}

const createDataset = `-- name: CreateDataset :one
INSERT INTO
  datasets (
    "dataproduct_id",
    "name",
    "description",
    "pii",
    "type",
    "slug",
    "repo",
    "keywords",
    "anonymisation_description",
    "target_user"
  )
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
  ) RETURNING id, name, description, pii, created, last_modified, type, tsv_document, slug, repo, keywords, dataproduct_id, anonymisation_description, target_user
`

type CreateDatasetParams struct {
	DataproductID            uuid.UUID
	Name                     string
	Description              sql.NullString
	Pii                      PiiLevel
	Type                     DatasourceType
	Slug                     string
	Repo                     sql.NullString
	Keywords                 []string
	AnonymisationDescription sql.NullString
	TargetUser               sql.NullString
}

func (q *Queries) CreateDataset(ctx context.Context, arg CreateDatasetParams) (Dataset, error) {
	row := q.db.QueryRowContext(ctx, createDataset,
		arg.DataproductID,
		arg.Name,
		arg.Description,
		arg.Pii,
		arg.Type,
		arg.Slug,
		arg.Repo,
		pq.Array(arg.Keywords),
		arg.AnonymisationDescription,
		arg.TargetUser,
	)
	var i Dataset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Pii,
		&i.Created,
		&i.LastModified,
		&i.Type,
		&i.TsvDocument,
		&i.Slug,
		&i.Repo,
		pq.Array(&i.Keywords),
		&i.DataproductID,
		&i.AnonymisationDescription,
		&i.TargetUser,
	)
	return i, err
}

const deleteDataset = `-- name: DeleteDataset :exec
DELETE FROM
  datasets
WHERE
  id = $1
`

func (q *Queries) DeleteDataset(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteDataset, id)
	return err
}

const getAccessiblePseudoDatasetsByUser = `-- name: GetAccessiblePseudoDatasetsByUser :many
WITH owned_dp AS(
  SELECT
    dp.id
  FROM
    dataproducts dp
  WHERE
    dp.group = ANY($2 :: text [])
)
SELECT
  included_ds.id AS dataset_id,
  included_ds.name AS name,
  sbq.project_id AS bq_project_id,
  sbq.dataset AS bq_dataset_id,
  sbq.table_name AS bq_table_id,
  sbq.id AS bq_datasource_id
FROM
  (
    (
      SELECT
        ds.id AS id,
        ds.name AS name,
        ds.dataproduct_id AS dataproduct_id
      FROM
        datasets ds
        INNER JOIN dataset_access da ON ds.id = da.dataset_id
      WHERE
        da.subject = ANY($1 :: text [])
        AND (
          da.revoked IS NULL
          AND(
            da.expires IS NULL
            OR da.expires > CURRENT_TIMESTAMP
          )
        )
      GROUP BY
        ds.id
    )
    UNION
    (
      SELECT
        ds.id AS id,
        ds.name AS name,
        ds.dataproduct_id AS dataproduct_id
      FROM
        datasets ds
        INNER JOIN owned_dp ON ds.dataproduct_id = owned_dp.id
    )
  ) AS included_ds
  INNER JOIN datasource_bigquery AS sbq ON included_ds.id = sbq.dataset_id
  AND sbq.is_reference = TRUE
`

type GetAccessiblePseudoDatasetsByUserParams struct {
	AccessSubjects []string
	OwnerSubjects  []string
}

type GetAccessiblePseudoDatasetsByUserRow struct {
	DatasetID      uuid.UUID
	Name           string
	BqProjectID    string
	BqDatasetID    string
	BqTableID      string
	BqDatasourceID uuid.UUID
}

func (q *Queries) GetAccessiblePseudoDatasetsByUser(ctx context.Context, arg GetAccessiblePseudoDatasetsByUserParams) ([]GetAccessiblePseudoDatasetsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAccessiblePseudoDatasetsByUser, pq.Array(arg.AccessSubjects), pq.Array(arg.OwnerSubjects))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccessiblePseudoDatasetsByUserRow{}
	for rows.Next() {
		var i GetAccessiblePseudoDatasetsByUserRow
		if err := rows.Scan(
			&i.DatasetID,
			&i.Name,
			&i.BqProjectID,
			&i.BqDatasetID,
			&i.BqTableID,
			&i.BqDatasourceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBigqueryDatasource = `-- name: GetBigqueryDatasource :one
SELECT
  dataset_id, project_id, dataset, table_name, schema, last_modified, created, expires, table_type, description, pii_tags, missing_since, id, is_reference, pseudo_columns, deleted
FROM
  datasource_bigquery
WHERE
  dataset_id = $1
  AND is_reference = $2
`

type GetBigqueryDatasourceParams struct {
	DatasetID   uuid.UUID
	IsReference bool
}

func (q *Queries) GetBigqueryDatasource(ctx context.Context, arg GetBigqueryDatasourceParams) (DatasourceBigquery, error) {
	row := q.db.QueryRowContext(ctx, getBigqueryDatasource, arg.DatasetID, arg.IsReference)
	var i DatasourceBigquery
	err := row.Scan(
		&i.DatasetID,
		&i.ProjectID,
		&i.Dataset,
		&i.TableName,
		&i.Schema,
		&i.LastModified,
		&i.Created,
		&i.Expires,
		&i.TableType,
		&i.Description,
		&i.PiiTags,
		&i.MissingSince,
		&i.ID,
		&i.IsReference,
		pq.Array(&i.PseudoColumns),
		&i.Deleted,
	)
	return i, err
}

const getBigqueryDatasources = `-- name: GetBigqueryDatasources :many
SELECT
  dataset_id, project_id, dataset, table_name, schema, last_modified, created, expires, table_type, description, pii_tags, missing_since, id, is_reference, pseudo_columns, deleted
FROM
  datasource_bigquery
`

func (q *Queries) GetBigqueryDatasources(ctx context.Context) ([]DatasourceBigquery, error) {
	rows, err := q.db.QueryContext(ctx, getBigqueryDatasources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DatasourceBigquery{}
	for rows.Next() {
		var i DatasourceBigquery
		if err := rows.Scan(
			&i.DatasetID,
			&i.ProjectID,
			&i.Dataset,
			&i.TableName,
			&i.Schema,
			&i.LastModified,
			&i.Created,
			&i.Expires,
			&i.TableType,
			&i.Description,
			&i.PiiTags,
			&i.MissingSince,
			&i.ID,
			&i.IsReference,
			pq.Array(&i.PseudoColumns),
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataset = `-- name: GetDataset :many
SELECT
  dataproduct_id, dp_name, dp_description, dp_group, dp_created, dp_last_modified, dp_slug, teamkatalogen_url, team_contact, team_id, bq_id, bq_created, bq_last_modified, bq_expires, bq_description, bq_missing_since, pii_tags, bq_project, bq_dataset, bq_table_name, bq_table_type, pseudo_columns, bq_schema, ds_dp_id, ds_id, ds_name, ds_description, ds_created, ds_last_modified, ds_slug, ds_keywords, mapping_services, access_id, access_subject, access_granter, access_expires, access_created, access_revoked, access_request_id, mb_database_id
FROM
  dataproduct_complete_view
WHERE
  ds_id = $1
`

func (q *Queries) GetDataset(ctx context.Context, id uuid.NullUUID) ([]DataproductCompleteView, error) {
	rows, err := q.db.QueryContext(ctx, getDataset, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DataproductCompleteView{}
	for rows.Next() {
		var i DataproductCompleteView
		if err := rows.Scan(
			&i.DataproductID,
			&i.DpName,
			&i.DpDescription,
			&i.DpGroup,
			&i.DpCreated,
			&i.DpLastModified,
			&i.DpSlug,
			&i.TeamkatalogenUrl,
			&i.TeamContact,
			&i.TeamID,
			&i.BqID,
			&i.BqCreated,
			&i.BqLastModified,
			&i.BqExpires,
			&i.BqDescription,
			&i.BqMissingSince,
			&i.PiiTags,
			&i.BqProject,
			&i.BqDataset,
			&i.BqTableName,
			&i.BqTableType,
			pq.Array(&i.PseudoColumns),
			&i.BqSchema,
			&i.DsDpID,
			&i.DsID,
			&i.DsName,
			&i.DsDescription,
			&i.DsCreated,
			&i.DsLastModified,
			&i.DsSlug,
			pq.Array(&i.DsKeywords),
			pq.Array(&i.MappingServices),
			&i.AccessID,
			&i.AccessSubject,
			&i.AccessGranter,
			&i.AccessExpires,
			&i.AccessCreated,
			&i.AccessRevoked,
			&i.AccessRequestID,
			&i.MbDatabaseID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatasetsByUserAccess = `-- name: GetDatasetsByUserAccess :many
SELECT
  dataproduct_id, dp_name, dp_description, dp_group, dp_created, dp_last_modified, dp_slug, teamkatalogen_url, team_contact, team_id, bq_id, bq_created, bq_last_modified, bq_expires, bq_description, bq_missing_since, pii_tags, bq_project, bq_dataset, bq_table_name, bq_table_type, pseudo_columns, bq_schema, ds_dp_id, ds_id, ds_name, ds_description, ds_created, ds_last_modified, ds_slug, ds_keywords, mapping_services, access_id, access_subject, access_granter, access_expires, access_created, access_revoked, access_request_id, mb_database_id
FROM
  dataproduct_complete_view
WHERE
  ds_id = ANY (
    SELECT
      dataset_id
    FROM
      dataset_access
    WHERE
      "subject" = LOWER($1)
      AND revoked IS NULL
      AND (
        expires > NOW()
        OR expires IS NULL
      )
  )
ORDER BY
  ds_last_modified DESC
`

func (q *Queries) GetDatasetsByUserAccess(ctx context.Context, id string) ([]DataproductCompleteView, error) {
	rows, err := q.db.QueryContext(ctx, getDatasetsByUserAccess, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DataproductCompleteView{}
	for rows.Next() {
		var i DataproductCompleteView
		if err := rows.Scan(
			&i.DataproductID,
			&i.DpName,
			&i.DpDescription,
			&i.DpGroup,
			&i.DpCreated,
			&i.DpLastModified,
			&i.DpSlug,
			&i.TeamkatalogenUrl,
			&i.TeamContact,
			&i.TeamID,
			&i.BqID,
			&i.BqCreated,
			&i.BqLastModified,
			&i.BqExpires,
			&i.BqDescription,
			&i.BqMissingSince,
			&i.PiiTags,
			&i.BqProject,
			&i.BqDataset,
			&i.BqTableName,
			&i.BqTableType,
			pq.Array(&i.PseudoColumns),
			&i.BqSchema,
			&i.DsDpID,
			&i.DsID,
			&i.DsName,
			&i.DsDescription,
			&i.DsCreated,
			&i.DsLastModified,
			&i.DsSlug,
			pq.Array(&i.DsKeywords),
			pq.Array(&i.MappingServices),
			&i.AccessID,
			&i.AccessSubject,
			&i.AccessGranter,
			&i.AccessExpires,
			&i.AccessCreated,
			&i.AccessRevoked,
			&i.AccessRequestID,
			&i.MbDatabaseID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatasetsForOwner = `-- name: GetDatasetsForOwner :many
SELECT
  dataproduct_id, dp_name, dp_description, dp_group, dp_created, dp_last_modified, dp_slug, teamkatalogen_url, team_contact, team_id, bq_id, bq_created, bq_last_modified, bq_expires, bq_description, bq_missing_since, pii_tags, bq_project, bq_dataset, bq_table_name, bq_table_type, pseudo_columns, bq_schema, ds_dp_id, ds_id, ds_name, ds_description, ds_created, ds_last_modified, ds_slug, ds_keywords, mapping_services, access_id, access_subject, access_granter, access_expires, access_created, access_revoked, access_request_id, mb_database_id
FROM
  dataproduct_complete_view
WHERE
  dataproduct_id IN (
    SELECT
      id
    FROM
      dataproducts dp
    WHERE
      dp.group = ANY($1 :: text [])
  )
`

func (q *Queries) GetDatasetsForOwner(ctx context.Context, groups []string) ([]DataproductCompleteView, error) {
	rows, err := q.db.QueryContext(ctx, getDatasetsForOwner, pq.Array(groups))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DataproductCompleteView{}
	for rows.Next() {
		var i DataproductCompleteView
		if err := rows.Scan(
			&i.DataproductID,
			&i.DpName,
			&i.DpDescription,
			&i.DpGroup,
			&i.DpCreated,
			&i.DpLastModified,
			&i.DpSlug,
			&i.TeamkatalogenUrl,
			&i.TeamContact,
			&i.TeamID,
			&i.BqID,
			&i.BqCreated,
			&i.BqLastModified,
			&i.BqExpires,
			&i.BqDescription,
			&i.BqMissingSince,
			&i.PiiTags,
			&i.BqProject,
			&i.BqDataset,
			&i.BqTableName,
			&i.BqTableType,
			pq.Array(&i.PseudoColumns),
			&i.BqSchema,
			&i.DsDpID,
			&i.DsID,
			&i.DsName,
			&i.DsDescription,
			&i.DsCreated,
			&i.DsLastModified,
			&i.DsSlug,
			pq.Array(&i.DsKeywords),
			pq.Array(&i.MappingServices),
			&i.AccessID,
			&i.AccessSubject,
			&i.AccessGranter,
			&i.AccessExpires,
			&i.AccessCreated,
			&i.AccessRevoked,
			&i.AccessRequestID,
			&i.MbDatabaseID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnerGroupOfDataset = `-- name: GetOwnerGroupOfDataset :one
SELECT
  d.group as group
FROM
  dataproducts d
WHERE
  d.id = (
    SELECT
      dataproduct_id
    FROM
      datasets ds
    WHERE
      ds.id = $1
  )
`

func (q *Queries) GetOwnerGroupOfDataset(ctx context.Context, datasetID uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, getOwnerGroupOfDataset, datasetID)
	var group string
	err := row.Scan(&group)
	return group, err
}

const getPseudoDatasourcesToDelete = `-- name: GetPseudoDatasourcesToDelete :many
SELECT
  bq.dataset_id, bq.project_id, bq.dataset, bq.table_name, bq.schema, bq.last_modified, bq.created, bq.expires, bq.table_type, bq.description, bq.pii_tags, bq.missing_since, bq.id, bq.is_reference, bq.pseudo_columns, bq.deleted
FROM
  datasource_bigquery bq
  LEFT JOIN datasets ds ON bq.dataset_id = ds.id
WHERE
  ds.id IS NULL
  AND bq.deleted is NULL
  AND ARRAY_LENGTH(bq.pseudo_columns, 1) > 0
`

func (q *Queries) GetPseudoDatasourcesToDelete(ctx context.Context) ([]DatasourceBigquery, error) {
	rows, err := q.db.QueryContext(ctx, getPseudoDatasourcesToDelete)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DatasourceBigquery{}
	for rows.Next() {
		var i DatasourceBigquery
		if err := rows.Scan(
			&i.DatasetID,
			&i.ProjectID,
			&i.Dataset,
			&i.TableName,
			&i.Schema,
			&i.LastModified,
			&i.Created,
			&i.Expires,
			&i.TableType,
			&i.Description,
			&i.PiiTags,
			&i.MissingSince,
			&i.ID,
			&i.IsReference,
			pq.Array(&i.PseudoColumns),
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const replaceDatasetsTag = `-- name: ReplaceDatasetsTag :exec
UPDATE
  datasets
SET
  "keywords" = array_replace(keywords, $1, $2)
`

type ReplaceDatasetsTagParams struct {
	TagToReplace interface{}
	TagUpdated   interface{}
}

func (q *Queries) ReplaceDatasetsTag(ctx context.Context, arg ReplaceDatasetsTagParams) error {
	_, err := q.db.ExecContext(ctx, replaceDatasetsTag, arg.TagToReplace, arg.TagUpdated)
	return err
}

const setDatasourceDeleted = `-- name: SetDatasourceDeleted :exec
UPDATE
  datasource_bigquery
SET
  deleted = NOW()
WHERE
  id = $1
`

func (q *Queries) SetDatasourceDeleted(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, setDatasourceDeleted, id)
	return err
}

const updateBigqueryDatasource = `-- name: UpdateBigqueryDatasource :exec
UPDATE
  datasource_bigquery
SET
  "pii_tags" = $1,
  "pseudo_columns" = $2
WHERE
  dataset_id = $3
`

type UpdateBigqueryDatasourceParams struct {
	PiiTags       pqtype.NullRawMessage
	PseudoColumns []string
	DatasetID     uuid.UUID
}

func (q *Queries) UpdateBigqueryDatasource(ctx context.Context, arg UpdateBigqueryDatasourceParams) error {
	_, err := q.db.ExecContext(ctx, updateBigqueryDatasource, arg.PiiTags, pq.Array(arg.PseudoColumns), arg.DatasetID)
	return err
}

const updateBigqueryDatasourceMissing = `-- name: UpdateBigqueryDatasourceMissing :exec
UPDATE
  datasource_bigquery
SET
  "missing_since" = NOW()
WHERE
  dataset_id = $1
`

func (q *Queries) UpdateBigqueryDatasourceMissing(ctx context.Context, datasetID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateBigqueryDatasourceMissing, datasetID)
	return err
}

const updateBigqueryDatasourceSchema = `-- name: UpdateBigqueryDatasourceSchema :exec
UPDATE
  datasource_bigquery
SET
  "schema" = $1,
  "last_modified" = $2,
  "expires" = $3,
  "description" = $4,
  "missing_since" = null,
  "pseudo_columns" = CASE
    WHEN $5 IS NOT NULL THEN $5
    ELSE "pseudo_columns"
  END
WHERE
  dataset_id = $6
`

type UpdateBigqueryDatasourceSchemaParams struct {
	Schema        pqtype.NullRawMessage
	LastModified  time.Time
	Expires       sql.NullTime
	Description   sql.NullString
	PseudoColumns []string
	DatasetID     uuid.UUID
}

func (q *Queries) UpdateBigqueryDatasourceSchema(ctx context.Context, arg UpdateBigqueryDatasourceSchemaParams) error {
	_, err := q.db.ExecContext(ctx, updateBigqueryDatasourceSchema,
		arg.Schema,
		arg.LastModified,
		arg.Expires,
		arg.Description,
		pq.Array(arg.PseudoColumns),
		arg.DatasetID,
	)
	return err
}

const updateDataset = `-- name: UpdateDataset :one
UPDATE
  datasets
SET
  "name" = $1,
  "description" = $2,
  "pii" = $3,
  "slug" = $4,
  "repo" = $5,
  "keywords" = $6,
  "dataproduct_id" = $7,
  "anonymisation_description" = $8,
  "target_user" = $9
WHERE
  id = $10 RETURNING id, name, description, pii, created, last_modified, type, tsv_document, slug, repo, keywords, dataproduct_id, anonymisation_description, target_user
`

type UpdateDatasetParams struct {
	Name                     string
	Description              sql.NullString
	Pii                      PiiLevel
	Slug                     string
	Repo                     sql.NullString
	Keywords                 []string
	DataproductID            uuid.UUID
	AnonymisationDescription sql.NullString
	TargetUser               sql.NullString
	ID                       uuid.UUID
}

func (q *Queries) UpdateDataset(ctx context.Context, arg UpdateDatasetParams) (Dataset, error) {
	row := q.db.QueryRowContext(ctx, updateDataset,
		arg.Name,
		arg.Description,
		arg.Pii,
		arg.Slug,
		arg.Repo,
		pq.Array(arg.Keywords),
		arg.DataproductID,
		arg.AnonymisationDescription,
		arg.TargetUser,
		arg.ID,
	)
	var i Dataset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Pii,
		&i.Created,
		&i.LastModified,
		&i.Type,
		&i.TsvDocument,
		&i.Slug,
		&i.Repo,
		pq.Array(&i.Keywords),
		&i.DataproductID,
		&i.AnonymisationDescription,
		&i.TargetUser,
	)
	return i, err
}
